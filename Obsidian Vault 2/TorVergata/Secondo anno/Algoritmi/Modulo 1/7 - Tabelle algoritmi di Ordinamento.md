#Algoritmi 


| Algoritmo       | Cosa fa                                                                                                                                                                                                                                                                                                                                                  | Codice                    | Costo                                                         | Parola Chiave                                                                              |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| Selection Sort  | Estende l'ordinamento da k a k+1 elementi, scegliendo il minimo degli n-k elementi non ancora ordinati e mettendolo in posizione k+1                                                                                                                                                                                                                     | [[2 - SelectionSort]]     | $O(n^2)$                                                      | Sceglie il minimo della parte non ancora ordinata                                          |
| Insertion Sort  | Estende l'ordinamento da k a k-1 elementi, posizionando l'elemento (k+1)-esimo nella posizione corretta rispetto ai primi k elementi                                                                                                                                                                                                                     | [[Insertion Sort]]        | $O(n^2)$                                                      | Inserisce ciascun elemento nella posizione corretta                                        |
| Bubble Sort<br> | Esegue n-1 scansioni. Ad ogni scansione guarda coppie di elementi adiacenti e li scambia se non sono nell'ordine<br>                                                                                                                                                                                                                                     | [[Bubble Sort]]           | $O(n^2)$                                                      | Scambia coppie di elementi                                                                 |
| Merge Sort      | Usa la tecnica del divide et impera:<br>1) Divide: dividi l'array a metà<br>2) Risolvi i due sottoproblemi ricorsivamente<br>3) Impera: fondi le due sottosequenze ordinate                                                                                                                                                                              | [[MergeSort]]             | $O(n \log n)$                                                 | Utilizza la tecnica Merge. Divide l'array, lo risove e fonde le due sottosequenze ordinate |
| Quick Sort      | Usa la tecnica del divide et impera:<br>1) Divide: scegli un elemento x dalla sequenza (perno) e partiziona la sequenza in elementi <=x ed elementi >x<br>2) Risolvi i due sottoproblemi ricorsivamente<br>3) Impera: restituisci la concatenazione delle due sottosequenza ordinate<br><br>(Rispetto al MergeSort, divide complesso ed impera semplice) | [[Quick Sort]]            | Caso peggiore = $O(n^2)$<br><br>Caso migliore = $O(n \log n)$ | Perni, partiziona in elementi <= x ed elementi >x                                          |
| FixHeap         | Sia v la radice di H. Assume che i sottoalberi radicati nel figlio sinistro e destro di v sono heap, ma la proprietà di ordinamento delle chiavi non vale per v                                                                                                                                                                                          | [[La procedura fixHeap]]  | $O(\log n)$                                                   | Scansiono le chiavi e scambio                                                              |
| Heapify         | Costruzione di un Heap, chiamata heapify su sottoalbero destro/sinistro. Infine fixHeap                                                                                                                                                                                                                                                                  | [[Costruzione dell'heap]] | $O(n)$                                                        | heapify ricorsivo + fixHeap                                                                |
| HeapSort        | Questo algoritmo scambia la radice con il minimo nell'Heap, decrementa heapsize (di conseguenza "taglia fuori" il massimo), utilizza il fixHeap per ricostruire la "gerarchia" dell'heap, e infine, avendo decrementato heapsize, trova il nuovo massimo, così ricorsivamente.                                                                           | [[HeapSort Codice]]       | $O(n \log n)$                                                 | Scambio il massimo, decremento Heapsize e aggiorno in modo ricorsivo                       |
| IntegerSort     | Algoritmo che non usa confronti<br>Per ordinare n interi con valori in [1, k]<br>Mantiene un array y di k contatori tale che y[x] = numero di volte che il valore x compare in X                                                                                                                                                                         | [[4 - IntegerSort]]       | $O(n + k)$<br>Tempo lineare se $K = O(n)$                     | Numeri del primo array = posizione del secondo array                                       |
| BucketSort      | Mantiene un Array di liste, lavora come l'IntegerSort                                                                                                                                                                                                                                                                                                    | [[5 - Bucket Sort]]       | $O(n + k)$                                                    | IntegerSort con array di liste                                                             |
| RadixSort       | - Ordina n interi con valori in [1,k]<br>- Rappresentiamo gli elementi in base b, ed eseguiamo una serie di BucketSort<br>- Partiamo dalla cifra meno significativa verso quella più significativa:<br>-Ordiniamo per l'i-esima cifra con una passata di BucketSort<br>-i-esima cifra è la chiave, il numero info satellite                              | [[6 - RadixSort]]         | $O(log k) // (log n)$                                         | "Matrici"                                                                                  |

